package repositories

import (
	"app-sistem-akuntansi/models"
	"app-sistem-akuntansi/utils"
	"context"
	"fmt"
	"gorm.io/gorm"
)

type JournalEntryRepository interface {
	Create(ctx context.Context, req *models.JournalEntryCreateRequest) (*models.JournalEntry, error)
	FindByID(ctx context.Context, id uint) (*models.JournalEntry, error)
	FindByCode(ctx context.Context, code string) (*models.JournalEntry, error)
	FindAll(ctx context.Context, filter *models.JournalEntryFilter) ([]models.JournalEntry, int64, error)
	Update(ctx context.Context, id uint, req *models.JournalEntryUpdateRequest) (*models.JournalEntry, error)
	Delete(ctx context.Context, id uint) error
	PostJournalEntry(ctx context.Context, id uint, userID uint) error
	ReverseJournalEntry(ctx context.Context, id uint, userID uint, reason string) (*models.JournalEntry, error)
	GetSummary(ctx context.Context) (*models.JournalEntrySummary, error)
	UpdateAccountBalances(ctx context.Context, entry *models.JournalEntry) error
	FindByReferenceID(ctx context.Context, referenceType string, referenceID uint) (*models.JournalEntry, error)
}

type JournalEntryRepo struct {
	DB *gorm.DB
}

func NewJournalEntryRepository(db *gorm.DB) JournalEntryRepository {
	return &JournalEntryRepo{DB: db}
}

// Create creates a new journal entry with validation
func (r *JournalEntryRepo) Create(ctx context.Context, req *models.JournalEntryCreateRequest) (*models.JournalEntry, error) {
	// Create journal entry
	entry := &models.JournalEntry{
		Description:     req.Description,
		Reference:       req.Reference,
		EntryDate:       req.EntryDate,
		Notes:           req.Notes,
		Status:          models.JournalStatusDraft,
		TotalDebit:      req.TotalDebit,
		TotalCredit:     req.TotalCredit,
		IsBalanced:      req.TotalDebit == req.TotalCredit,
		AccountID:       req.AccountID,
		ReferenceType:   req.ReferenceType,
		ReferenceID:     req.ReferenceID,
		UserID:          req.UserID,
		IsAutoGenerated: req.IsAutoGenerated,
	}

	if err := r.DB.WithContext(ctx).Create(entry).Error; err != nil {
		return nil, utils.NewInternalError("Failed to create journal entry", err)
	}

	// Reload with relations
	return r.FindByID(ctx, entry.ID)
}

// FindByID finds journal entry by ID
func (r *JournalEntryRepo) FindByID(ctx context.Context, id uint) (*models.JournalEntry, error) {
	var entry models.JournalEntry

	err := r.DB.WithContext(ctx).
		Preload("Creator").
		Preload("Poster").
		Preload("Journal").
		Preload("Account").
		Preload("ReversalEntry").
		Preload("ReversedEntry").
		First(&entry, id).Error

	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, utils.NewNotFoundError("Journal entry not found")
		}
		return nil, utils.NewInternalError("Failed to find journal entry", err)
	}

	return &entry, nil
}

// FindByCode finds journal entry by code
func (r *JournalEntryRepo) FindByCode(ctx context.Context, code string) (*models.JournalEntry, error) {
	var entry models.JournalEntry

	err := r.DB.WithContext(ctx).
		Preload("Creator").
		Preload("Poster").
		Preload("Journal").
		Preload("Account").
		Where("code = ?", code).
		First(&entry).Error

	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, utils.NewNotFoundError("Journal entry not found")
		}
		return nil, utils.NewInternalError("Failed to find journal entry", err)
	}

	return &entry, nil
}

// FindAll finds journal entries with filtering
func (r *JournalEntryRepo) FindAll(ctx context.Context, filter *models.JournalEntryFilter) ([]models.JournalEntry, int64, error) {
	var entries []models.JournalEntry
	var total int64

	query := r.DB.WithContext(ctx).Model(&models.JournalEntry{})

	// Apply filters
	if filter.Status != "" {
		query = query.Where("status = ?", filter.Status)
	}

	if filter.ReferenceType != "" {
		query = query.Where("reference_type = ?", filter.ReferenceType)
	}

	if filter.StartDate != "" {
		query = query.Where("entry_date >= ?", filter.StartDate)
	}

	if filter.EndDate != "" {
		query = query.Where("entry_date <= ?", filter.EndDate)
	}

	if filter.Search != "" {
		searchTerm := "%" + filter.Search + "%"
		query = query.Where("description LIKE ? OR reference LIKE ? OR code LIKE ?", searchTerm, searchTerm, searchTerm)
	}

	if filter.AccountID != "" {
		// Filter by entries that have specific account ID
		query = query.Where("account_id = ?", filter.AccountID)
	}

	// Get total count
	if err := query.Count(&total).Error; err != nil {
		return nil, 0, utils.NewInternalError("Failed to count journal entries", err)
	}

	// Apply pagination
	page := filter.Page
	if page <= 0 {
		page = 1
	}

	limit := filter.Limit
	if limit <= 0 {
		limit = 20
	}

	offset := (page - 1) * limit

	err := query.
		Preload("Creator").
		Preload("Poster").
		Preload("Journal").
		Preload("Account").
		Order("entry_date DESC, created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&entries).Error

	if err != nil {
		return nil, 0, utils.NewInternalError("Failed to find journal entries", err)
	}

	return entries, total, nil
}

// Update updates journal entry (only if in DRAFT status)
func (r *JournalEntryRepo) Update(ctx context.Context, id uint, req *models.JournalEntryUpdateRequest) (*models.JournalEntry, error) {
	// Find existing entry
	entry, err := r.FindByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// Check if entry can be updated
	if entry.Status != models.JournalStatusDraft {
		return nil, utils.NewBadRequestError("Only draft journal entries can be updated")
	}

	// Start transaction
	tx := r.DB.WithContext(ctx).Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Update entry fields
	updates := make(map[string]interface{})

	if req.Description != nil {
		updates["description"] = *req.Description
	}

	if req.Reference != nil {
		updates["reference"] = *req.Reference
	}

	if req.EntryDate != nil {
		updates["entry_date"] = *req.EntryDate
	}

	if req.Notes != nil {
		updates["notes"] = *req.Notes
	}

	if len(updates) > 0 {
		if err := tx.Model(entry).Updates(updates).Error; err != nil {
			tx.Rollback()
			return nil, utils.NewInternalError("Failed to update journal entry", err)
		}
	}

	// Note: journal lines are no longer supported in the simplified model

	// Commit transaction
	if err := tx.Commit().Error; err != nil {
		return nil, utils.NewInternalError("Failed to commit journal entry update", err)
	}

	// Return updated entry
	return r.FindByID(ctx, entry.ID)
}

// Delete deletes journal entry (only if in DRAFT status)
func (r *JournalEntryRepo) Delete(ctx context.Context, id uint) error {
	// Find existing entry
	entry, err := r.FindByID(ctx, id)
	if err != nil {
		return err
	}

	// Check if entry can be deleted
	if entry.Status != models.JournalStatusDraft {
		return utils.NewBadRequestError("Only draft journal entries can be deleted")
	}

	// Start transaction
	tx := r.DB.WithContext(ctx).Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Note: journal lines are no longer supported in the simplified model

	// Delete journal entry
	if err := tx.Delete(&models.JournalEntry{}, id).Error; err != nil {
		tx.Rollback()
		return utils.NewInternalError("Failed to delete journal entry", err)
	}

	// Commit transaction
	if err := tx.Commit().Error; err != nil {
		return utils.NewInternalError("Failed to commit journal entry deletion", err)
	}

	return nil
}

// PostJournalEntry posts a journal entry to update account balances
func (r *JournalEntryRepo) PostJournalEntry(ctx context.Context, id uint, userID uint) error {
	// Find entry
	entry, err := r.FindByID(ctx, id)
	if err != nil {
		return err
	}

	// Check if entry can be posted
	if entry.Status != models.JournalStatusDraft {
		return utils.NewBadRequestError("Only draft journal entries can be posted")
	}

	if !entry.IsBalanced {
		return utils.NewBadRequestError("Journal entry must be balanced to post")
	}

	// Start transaction
	tx := r.DB.WithContext(ctx).Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Update account balances
	if err := r.updateAccountBalancesInTx(tx, entry); err != nil {
		tx.Rollback()
		return err
	}

	// Update entry status
	now := gorm.Expr("NOW()")
	if err := tx.Model(entry).Updates(map[string]interface{}{
		"status":       models.JournalStatusPosted,
		"posted_by":    userID,
		"posting_date": now,
	}).Error; err != nil {
		tx.Rollback()
		return utils.NewInternalError("Failed to update journal entry status", err)
	}

	// Commit transaction
	if err := tx.Commit().Error; err != nil {
		return utils.NewInternalError("Failed to commit journal entry posting", err)
	}

	return nil
}

// ReverseJournalEntry creates a reversing journal entry
func (r *JournalEntryRepo) ReverseJournalEntry(ctx context.Context, id uint, userID uint, reason string) (*models.JournalEntry, error) {
	// Find original entry
	originalEntry, err := r.FindByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// Check if entry can be reversed
	if originalEntry.Status != models.JournalStatusPosted {
		return nil, utils.NewBadRequestError("Only posted journal entries can be reversed")
	}

	// Start transaction
	tx := r.DB.WithContext(ctx).Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Create reversing entry
	reversingEntry := &models.JournalEntry{
		Description:     fmt.Sprintf("REVERSAL: %s - %s", originalEntry.Description, reason),
		Reference:       originalEntry.Reference,
		ReferenceType:   originalEntry.ReferenceType,
		ReferenceID:     originalEntry.ReferenceID,
		EntryDate:       originalEntry.EntryDate,
		UserID:          userID,
		Status:          models.JournalStatusDraft,
		TotalDebit:      originalEntry.TotalDebit,
		TotalCredit:     originalEntry.TotalCredit,
		IsBalanced:      true,
		IsAutoGenerated: false,
		ReversedID:      &originalEntry.ID,
		Notes:           fmt.Sprintf("Reversal of journal entry %s. Reason: %s", originalEntry.Code, reason),
	}

	if err := tx.Create(reversingEntry).Error; err != nil {
		tx.Rollback()
		return nil, utils.NewInternalError("Failed to create reversing journal entry", err)
	}

	// Note: journal lines are no longer supported in the simplified model
	// Swap debit and credit amounts for reversal
	reversingEntry.TotalDebit = originalEntry.TotalCredit
	reversingEntry.TotalCredit = originalEntry.TotalDebit

	// Update original entry to point to reversal
	if err := tx.Model(originalEntry).Updates(map[string]interface{}{
		"reversal_id": reversingEntry.ID,
		"status":      models.JournalStatusReversed,
	}).Error; err != nil {
		tx.Rollback()
		return nil, utils.NewInternalError("Failed to update original journal entry", err)
	}

	// Commit transaction
	if err := tx.Commit().Error; err != nil {
		return nil, utils.NewInternalError("Failed to commit journal reversal", err)
	}

	// Return the reversing entry
	return r.FindByID(ctx, reversingEntry.ID)
}

// GetSummary gets journal entry summary statistics
func (r *JournalEntryRepo) GetSummary(ctx context.Context) (*models.JournalEntrySummary, error) {
	var summary models.JournalEntrySummary

	// Get total counts and amounts
	err := r.DB.WithContext(ctx).Model(&models.JournalEntry{}).
		Select("COUNT(*) as total_entries, SUM(total_debit) as total_debit, SUM(total_credit) as total_credit, SUM(CASE WHEN is_balanced = true THEN 1 ELSE 0 END) as balanced_entries").
		Scan(&summary).Error

	if err != nil {
		return nil, utils.NewInternalError("Failed to get journal entry summary", err)
	}

	// Get status counts
	var statusCounts []struct {
		Status string `json:"status"`
		Count  int64  `json:"count"`
	}

	err = r.DB.WithContext(ctx).Model(&models.JournalEntry{}).
		Select("status, COUNT(*) as count").
		Group("status").
		Scan(&statusCounts).Error

	if err != nil {
		return nil, utils.NewInternalError("Failed to get status counts", err)
	}

	summary.StatusCounts = make(map[string]int64)
	for _, sc := range statusCounts {
		summary.StatusCounts[sc.Status] = sc.Count
	}

	// Get type counts
	var typeCounts []struct {
		ReferenceType string `json:"reference_type"`
		Count         int64  `json:"count"`
	}

	err = r.DB.WithContext(ctx).Model(&models.JournalEntry{}).
		Select("reference_type, COUNT(*) as count").
		Where("reference_type IS NOT NULL AND reference_type != ''").
		Group("reference_type").
		Scan(&typeCounts).Error

	if err != nil {
		return nil, utils.NewInternalError("Failed to get type counts", err)
	}

	summary.TypeCounts = make(map[string]int64)
	for _, tc := range typeCounts {
		summary.TypeCounts[tc.ReferenceType] = tc.Count
	}

	return &summary, nil
}

// UpdateAccountBalances updates account balances for a journal entry
func (r *JournalEntryRepo) UpdateAccountBalances(ctx context.Context, entry *models.JournalEntry) error {
	return r.updateAccountBalancesInTx(r.DB.WithContext(ctx), entry)
}

// updateAccountBalancesInTx updates account balances within a transaction
func (r *JournalEntryRepo) updateAccountBalancesInTx(tx *gorm.DB, entry *models.JournalEntry) error {
	// For purchase transactions, we need to update multiple accounts
	// This simplified approach updates balances based on the journal entry details

	if entry.ReferenceType == models.JournalRefPurchase {
		// For purchase transactions, update multiple accounts involved:
		// 1. Expense/Inventory accounts (Debit increases)
		// 2. Accounts Payable (Credit increases)
		// 3. PPN Receivable (Debit increases)

		// Get the purchase to access actual expense accounts from purchase items
		var purchase models.Purchase
		if entry.ReferenceID != nil {
			fmt.Printf("\nðŸ” DEBUG: Processing purchase journal entry for ReferenceID: %d\n", *entry.ReferenceID)
			if err := tx.Preload("PurchaseItems").First(&purchase, *entry.ReferenceID).Error; err == nil {
				// Update actual expense accounts from purchase items
				for _, item := range purchase.PurchaseItems {
					if item.ExpenseAccountID != 0 {
						var expenseAccount models.Account
						if err := tx.First(&expenseAccount, item.ExpenseAccountID).Error; err == nil {
							// For expense accounts (debit normal balance), debit increases balance
							// Use actual item total price as expense increase
							if err := tx.Model(&expenseAccount).Update("balance", gorm.Expr("balance + ?", item.TotalPrice)).Error; err != nil {
								return utils.NewInternalError("Failed to update expense account balance", err)
							}
							fmt.Printf("Updated Expense Account %d balance by +%.2f (from purchase item)\n", item.ExpenseAccountID, item.TotalPrice)
						} else {
							fmt.Printf("Warning: Could not find expense account ID %d\n", item.ExpenseAccountID)
						}
					}
				}
			} else {
				fmt.Printf("Warning: Could not load purchase details for journal entry\n")
				// Fallback to primary account if purchase details unavailable
				if entry.AccountID != nil {
					var expenseAccount models.Account
					if err := tx.First(&expenseAccount, *entry.AccountID).Error; err == nil {
						// Use net before tax as expense increase (more accurate than 90%)
						expenseIncrease := entry.TotalDebit - (entry.TotalDebit * 0.11) // Subtract standard PPN 11%
						if err := tx.Model(&expenseAccount).Update("balance", gorm.Expr("balance + ?", expenseIncrease)).Error; err != nil {
							return utils.NewInternalError("Failed to update expense account balance", err)
						}
						fmt.Printf("Updated Primary Expense Account %d balance by +%.2f (fallback)\n", *entry.AccountID, expenseIncrease)
					}
				}
			}
		}

		// Update PPN Receivable account (PPN Masukan account) using actual PPN amount
		if entry.ReferenceID != nil {
			var purchase models.Purchase
			if err := tx.First(&purchase, *entry.ReferenceID).Error; err == nil && purchase.PPNAmount > 0 {
				var ppnAccount models.Account
				if err := tx.Where("code = ? OR name ILIKE ?", "1106", "%PPN%Masukan%").First(&ppnAccount).Error; err == nil {
					// PPN Masukan is a debit normal account, so debit increases balance
					if err := tx.Model(&ppnAccount).Update("balance", gorm.Expr("balance + ?", purchase.PPNAmount)).Error; err != nil {
						return utils.NewInternalError("Failed to update PPN account balance", err)
					}
					fmt.Printf("Updated PPN Receivable Account %d balance by +%.2f (actual PPN amount)\n", ppnAccount.ID, purchase.PPNAmount)
				} else {
					fmt.Printf("Warning: Could not find PPN Masukan account to update\n")
				}
			}
		}

		// Use the purchase we already loaded for payment method determination
		// (purchase variable is already available from above)

		// Update credit side account based on payment method
		if purchase.PaymentMethod == models.PurchasePaymentCash ||
			purchase.PaymentMethod == models.PurchasePaymentTransfer ||
			purchase.PaymentMethod == models.PurchasePaymentCheck {
			// For immediate payment: Credit Bank/Cash Account
			if purchase.BankAccountID != nil {
				var cashBank models.CashBank
				if err := tx.First(&cashBank, *purchase.BankAccountID).Error; err == nil {
					// Update the linked GL account for the bank
					if err := tx.Model(&models.Account{}).Where("id = ?", cashBank.AccountID).Update("balance", gorm.Expr("balance - ?", entry.TotalCredit)).Error; err != nil {
						return utils.NewInternalError("Failed to update bank account balance", err)
					}
					fmt.Printf("Updated Bank Account %s balance by -%.2f\n", cashBank.Name, entry.TotalCredit)

					// Also update cash bank balance for reconciliation
					if err := tx.Model(&cashBank).Update("balance", gorm.Expr("balance - ?", entry.TotalCredit)).Error; err != nil {
						return utils.NewInternalError("Failed to update cash bank balance", err)
					}
				} else {
					fmt.Printf("Warning: Could not find bank account ID %d\n", *purchase.BankAccountID)
				}
			}
		} else {
			// For credit purchase: Use CreditAccountID specified by user
			var payableAccount models.Account
			
			// Priority 1: Use the CreditAccountID selected by user
			if purchase.CreditAccountID != nil {
				fmt.Printf("ðŸ’° DEBUG: User selected CreditAccountID: %d\n", *purchase.CreditAccountID)
				if err := tx.First(&payableAccount, *purchase.CreditAccountID).Error; err == nil {
					fmt.Printf("âœ… DEBUG: Found credit account: %s (ID: %d, Code: %s)\n", payableAccount.Name, payableAccount.ID, payableAccount.Code)
					// Credit the specific liability account chosen by user
					if err := tx.Model(&payableAccount).Update("balance", gorm.Expr("balance + ?", entry.TotalCredit)).Error; err != nil {
						return utils.NewInternalError("Failed to update liability account balance", err)
					}
					fmt.Printf("Updated %s Account %d balance by +%.2f\n", payableAccount.Name, payableAccount.ID, entry.TotalCredit)
				} else {
					fmt.Printf("Warning: Could not find selected credit account ID %d\n", *purchase.CreditAccountID)
					// Fallback to default accounts payable search
					if err := tx.Where("code = ? OR code = ? OR name ILIKE ? OR name ILIKE ?", "2101", "2001", "%Hutang%Usaha%", "%Accounts%Payable%").First(&payableAccount).Error; err == nil {
						if err := tx.Model(&payableAccount).Update("balance", gorm.Expr("balance + ?", entry.TotalCredit)).Error; err != nil {
							return utils.NewInternalError("Failed to update accounts payable balance", err)
						}
						fmt.Printf("Updated Default Accounts Payable Account %d balance by +%.2f (fallback)\n", payableAccount.ID, entry.TotalCredit)
					} else {
						fmt.Printf("Error: Could not find any liability account to update\n")
					}
				}
			} else {
				// Priority 2: Fallback to default search if no CreditAccountID specified
				fmt.Printf("Warning: No CreditAccountID specified, using default search\n")
				if err := tx.Where("code = ? OR code = ? OR name ILIKE ? OR name ILIKE ?", "2101", "2001", "%Hutang%Usaha%", "%Accounts%Payable%").First(&payableAccount).Error; err == nil {
					// Accounts Payable is a credit normal account, so credit increases balance
					if err := tx.Model(&payableAccount).Update("balance", gorm.Expr("balance + ?", entry.TotalCredit)).Error; err != nil {
						return utils.NewInternalError("Failed to update accounts payable balance", err)
					}
					fmt.Printf("Updated Default Accounts Payable Account %d balance by +%.2f\n", payableAccount.ID, entry.TotalCredit)
				} else {
					fmt.Printf("Warning: Could not find any Accounts Payable account to update\n")
				}
			}
		}

	} else {
		// For other transaction types, use the original simple approach
		if entry.AccountID != nil {
			// Get account to determine normal balance
			var account models.Account
			if err := tx.First(&account, *entry.AccountID).Error; err != nil {
				return utils.NewInternalError("Failed to find account for balance update", err)
			}

			// Calculate balance change based on normal balance type and journal entry totals
			var balanceChange float64
			normalBalance := account.GetNormalBalance()

			if normalBalance == models.NormalBalanceDebit {
				// For debit normal accounts: debit increases, credit decreases
				balanceChange = entry.TotalDebit - entry.TotalCredit
			} else {
				// For credit normal accounts: credit increases, debit decreases
				balanceChange = entry.TotalCredit - entry.TotalDebit
			}

			// Update account balance
			if err := tx.Model(&account).Update("balance", gorm.Expr("balance + ?", balanceChange)).Error; err != nil {
				return utils.NewInternalError("Failed to update account balance", err)
			}
			fmt.Printf("Updated Account %d balance by %.2f\n", *entry.AccountID, balanceChange)
		}
	}

	return nil
}

// FindByReferenceID finds journal entry by reference type and ID
// Returns nil, nil if not found (no error for not found case)
func (r *JournalEntryRepo) FindByReferenceID(ctx context.Context, referenceType string, referenceID uint) (*models.JournalEntry, error) {
	var entry models.JournalEntry

	err := r.DB.WithContext(ctx).
		Preload("Creator").
		Preload("Poster").
		Preload("Journal").
		Preload("Account").
		Where("reference_type = ? AND reference_id = ?", referenceType, referenceID).
		First(&entry).Error

	if err != nil {
		if err == gorm.ErrRecordNotFound {
			// Return nil, nil for not found - this is expected for new records
			return nil, nil
		}
		return nil, utils.NewInternalError("Failed to find journal entry", err)
	}

	return &entry, nil
}
