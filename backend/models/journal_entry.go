package models

import (
	"fmt"
	"time"
	"gorm.io/gorm"
)

// JournalEntry represents a complete journal entry in the double-entry bookkeeping system
type JournalEntry struct {
	ID              uint           `json:"id" gorm:"primaryKey"`
	JournalID       *uint          `json:"journal_id" gorm:"index"`                   // Reference to parent journal (optional)
	AccountID       *uint          `json:"account_id" gorm:"index"`                   // Primary account ID for simple entries
	Code            string         `json:"code" gorm:"unique;not null;size:30;index"` // JE-YYYY-MM-XXXX
	Description     string         `json:"description" gorm:"not null;type:text"`
	Reference       string         `json:"reference" gorm:"size:100"`                 // Reference to source transaction
	ReferenceType   string         `json:"reference_type" gorm:"size:50"`             // SALE, PURCHASE, PAYMENT, MANUAL, etc.
	ReferenceID     *uint          `json:"reference_id" gorm:"index"`                 // ID of source transaction
	EntryDate       time.Time      `json:"entry_date" gorm:"not null"`               // Journal entry date
	PostingDate     *time.Time     `json:"posting_date"`                             // When posted to GL
	UserID          uint           `json:"user_id" gorm:"not null;index"`            // User who created the entry
	PostedBy        *uint          `json:"posted_by" gorm:"index"`                   // User who posted the entry
	Status          string         `json:"status" gorm:"size:20;default:'DRAFT'"`    // DRAFT, POSTED, REVERSED
	TotalDebit      float64        `json:"total_debit" gorm:"type:decimal(20,2);default:0"`
	TotalCredit     float64        `json:"total_credit" gorm:"type:decimal(20,2);default:0"`
	IsBalanced      bool           `json:"is_balanced" gorm:"default:false"`         // Auto-calculated: debit = credit
	IsAutoGenerated bool           `json:"is_auto_generated" gorm:"default:false"`   // Auto vs Manual entry
	ReversalID      *uint          `json:"reversal_id" gorm:"index"`                 // Points to reversing entry
	ReversedID      *uint          `json:"reversed_id" gorm:"index"`                 // Points to original entry being reversed
	Notes           string         `json:"notes" gorm:"type:text"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
	DeletedAt       gorm.DeletedAt `json:"-" gorm:"index"`

	// Relations
	Journal        *Journal              `json:"journal,omitempty" gorm:"foreignKey:JournalID"`
	Account        *Account              `json:"account,omitempty" gorm:"foreignKey:AccountID"`
	Creator        User                  `json:"creator" gorm:"foreignKey:UserID"`
	Poster         *User                 `json:"poster,omitempty" gorm:"foreignKey:PostedBy"`
	JournalLines   []JournalLine         `json:"journal_lines" gorm:"foreignKey:JournalEntryID"`
	ReversalEntry  *JournalEntry         `json:"reversal_entry,omitempty" gorm:"foreignKey:ReversalID"`
	ReversedEntry  *JournalEntry         `json:"reversed_entry,omitempty" gorm:"foreignKey:ReversedID"`
}

// JournalLine represents individual debit/credit lines in a journal entry
type JournalLine struct {
	ID             uint           `json:"id" gorm:"primaryKey"`
	JournalEntryID uint           `json:"journal_entry_id" gorm:"not null;index"`
	AccountID      uint           `json:"account_id" gorm:"not null;index"`
	Description    string         `json:"description" gorm:"type:text"`
	DebitAmount    float64        `json:"debit_amount" gorm:"type:decimal(20,2);default:0"`
	CreditAmount   float64        `json:"credit_amount" gorm:"type:decimal(20,2);default:0"`
	LineNumber     int            `json:"line_number" gorm:"not null"`               // Order of lines in entry
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	DeletedAt      gorm.DeletedAt `json:"-" gorm:"index"`

	// Relations
	JournalEntry JournalEntry `json:"-" gorm:"foreignKey:JournalEntryID"` // Exclude to prevent circular reference
	Account      Account      `json:"account" gorm:"foreignKey:AccountID"`
}

// Journal Entry Status Constants
const (
	JournalStatusDraft    = "DRAFT"
	JournalStatusPosted   = "POSTED"
	JournalStatusReversed = "REVERSED"
)

// Journal Entry Reference Types Constants
const (
	JournalRefSale     = "SALE"
	JournalRefPurchase = "PURCHASE"
	JournalRefPayment  = "PAYMENT"
	JournalRefCashBank = "CASH_BANK"
	JournalRefAsset    = "ASSET"
	JournalRefManual   = "MANUAL"
	JournalRefOpening  = "OPENING_BALANCE"
	JournalRefClosing  = "CLOSING_BALANCE"
	JournalRefTransfer = "TRANSFER"
	JournalRefDeposit  = "DEPOSIT"
	JournalRefWithdrawal = "WITHDRAWAL"
)

// Request/Response DTOs
type JournalEntryCreateRequest struct {
	Description     string    `json:"description" binding:"required"`
	Reference       string    `json:"reference"`
	ReferenceType   string    `json:"reference_type"`
	ReferenceID     *uint     `json:"reference_id"`
	EntryDate       time.Time `json:"entry_date" binding:"required"`
	Notes           string    `json:"notes"`
	UserID          uint      `json:"user_id" binding:"required"`
	AccountID       *uint     `json:"account_id"`
	TotalDebit      float64   `json:"total_debit"`
	TotalCredit     float64   `json:"total_credit"`
	IsAutoGenerated bool      `json:"is_auto_generated"`
}

type JournalLineCreateRequest struct {
	AccountID     uint    `json:"account_id" binding:"required"`
	Description   string  `json:"description"`
	DebitAmount   float64 `json:"debit_amount"`
	CreditAmount  float64 `json:"credit_amount"`
}

type JournalEntryUpdateRequest struct {
	Description  *string                     `json:"description"`
	Reference    *string                     `json:"reference"`
	EntryDate    *time.Time                  `json:"entry_date"`
	Notes        *string                     `json:"notes"`
	JournalLines []JournalLineCreateRequest  `json:"journal_lines"`
}

// Validation methods
func (je *JournalEntry) ValidateBalance() bool {
	var totalDebit, totalCredit float64
	
	for _, line := range je.JournalLines {
		totalDebit += line.DebitAmount
		totalCredit += line.CreditAmount
	}
	
	je.TotalDebit = totalDebit
	je.TotalCredit = totalCredit
	je.IsBalanced = (totalDebit == totalCredit) && (totalDebit > 0)
	
	return je.IsBalanced
}

// GORM Hooks
func (je *JournalEntry) BeforeCreate(tx *gorm.DB) error {
	// Generate journal entry code only if not provided
	if je.Code == "" {
		now := time.Now()
		var count int64
		// Count journal entries created today to generate unique sequence
		tx.Model(&JournalEntry{}).Where("DATE(created_at) = ?", now.Format("2006-01-02")).Count(&count)
		
		// Keep trying to generate a unique code
		for i := 1; i <= 100; i++ {
			proposedCode := fmt.Sprintf("JE-%s-%04d", now.Format("2006-01-02"), count+int64(i))
			
			// Check if this code already exists
			var existingCount int64
			tx.Model(&JournalEntry{}).Where("code = ?", proposedCode).Count(&existingCount)
			
			if existingCount == 0 {
				je.Code = proposedCode
				break
			}
		}
		
		// Final fallback - use timestamp if all else fails
		if je.Code == "" {
			je.Code = fmt.Sprintf("JE-%s-%d", now.Format("2006-01-02"), now.Unix())
		}
	}
	return nil
}

func (je *JournalEntry) BeforeSave(tx *gorm.DB) error {
	// Note: ValidateBalance() has been disabled because we're not using journal lines anymore
	// The totals are now set directly when creating the journal entry
	// je.ValidateBalance()
	return nil
}

// Auto-generate journal entries for sales
func GenerateSaleJournalEntry(sale Sale) *JournalEntry {
	entry := &JournalEntry{
		Description:     fmt.Sprintf("Sales Invoice %s - %s", sale.Code, sale.Customer.Name),
		Reference:       sale.Code,
		ReferenceType:   JournalRefSale,
		ReferenceID:     &sale.ID,
		EntryDate:       sale.Date,
		UserID:          sale.UserID,
		IsAutoGenerated: true,
		Status:          JournalStatusDraft,
	}

	// Generate journal lines
	var lines []JournalLine

	// 1. Debit: Accounts Receivable (if not cash sale)
	if sale.OutstandingAmount > 0 {
		lines = append(lines, JournalLine{
			AccountID:    1201, // Piutang Usaha account ID
			Description:  fmt.Sprintf("Accounts Receivable - %s", sale.Customer.Name),
			DebitAmount:  sale.OutstandingAmount,
			LineNumber:   1,
		})
	}

	// 2. Debit: Cash/Bank (if cash received)
	if sale.PaidAmount > 0 {
		lines = append(lines, JournalLine{
			AccountID:    1101, // Kas account ID
			Description:  fmt.Sprintf("Cash Received - %s", sale.Customer.Name),
			DebitAmount:  sale.PaidAmount,
			LineNumber:   len(lines) + 1,
		})
	}

	// 3. Credit: Sales Revenue
	for _, item := range sale.SaleItems {
		lines = append(lines, JournalLine{
			AccountID:    item.RevenueAccountID,
			Description:  fmt.Sprintf("Sales Revenue - %s", item.Product.Name),
			CreditAmount: item.LineTotal,
			LineNumber:   len(lines) + 1,
		})
	}

	// 4. Credit: PPN Payable (if applicable)
	if sale.PPN > 0 {
		lines = append(lines, JournalLine{
			AccountID:    2101, // PPN Keluaran account ID
			Description:  "PPN Keluaran",
			CreditAmount: sale.PPN,
			LineNumber:   len(lines) + 1,
		})
	}

	entry.JournalLines = lines
	entry.ValidateBalance()

	return entry
}

// Auto-generate journal entries for purchases
func GeneratePurchaseJournalEntry(purchase Purchase) *JournalEntry {
	entry := &JournalEntry{
		Description:     fmt.Sprintf("Purchase Invoice %s - %s", purchase.Code, purchase.Vendor.Name),
		Reference:       purchase.Code,
		ReferenceType:   JournalRefPurchase,
		ReferenceID:     &purchase.ID,
		EntryDate:       purchase.Date,
		UserID:          purchase.UserID,
		IsAutoGenerated: true,
		Status:          JournalStatusDraft,
	}

	var lines []JournalLine

	// 1. Debit: Expense/Inventory Accounts
	for _, item := range purchase.PurchaseItems {
		lines = append(lines, JournalLine{
			AccountID:    item.ExpenseAccountID,
			Description:  fmt.Sprintf("Purchase - %s", item.Product.Name),
			DebitAmount:  item.TotalPrice,
			LineNumber:   len(lines) + 1,
		})
	}

	// 2. Debit: PPN Masukan (if applicable)
	if purchase.PPNAmount > 0 {
		lines = append(lines, JournalLine{
			AccountID:    1105, // PPN Masukan account ID
			Description:  "PPN Masukan",
			DebitAmount:  purchase.PPNAmount,
			LineNumber:   len(lines) + 1,
		})
	}

	// 3. Credit: Accounts Payable (if not cash purchase)
	if purchase.OutstandingAmount > 0 {
		lines = append(lines, JournalLine{
			AccountID:    2001, // Hutang Usaha account ID
			Description:  fmt.Sprintf("Accounts Payable - %s", purchase.Vendor.Name),
			CreditAmount: purchase.OutstandingAmount,
			LineNumber:   len(lines) + 1,
		})
	}

	// 4. Credit: Cash/Bank (if cash paid)
	if purchase.PaidAmount > 0 {
		lines = append(lines, JournalLine{
			AccountID:    1101, // Kas account ID
			Description:  fmt.Sprintf("Cash Paid - %s", purchase.Vendor.Name),
			CreditAmount: purchase.PaidAmount,
			LineNumber:   len(lines) + 1,
		})
	}

	entry.JournalLines = lines
	entry.ValidateBalance()

	return entry
}

// Journal Entry Filter for listing
type JournalEntryFilter struct {
	Status        string `json:"status"`
	ReferenceType string `json:"reference_type"`
	AccountID     string `json:"account_id"`
	StartDate     string `json:"start_date"`
	EndDate       string `json:"end_date"`
	Search        string `json:"search"`
	Page          int    `json:"page"`
	Limit         int    `json:"limit"`
}

// Journal Entry Summary for reporting
type JournalEntrySummary struct {
	TotalEntries   int64              `json:"total_entries"`
	TotalDebit     float64            `json:"total_debit"`
	TotalCredit    float64            `json:"total_credit"`
	BalancedEntries int64             `json:"balanced_entries"`
	StatusCounts   map[string]int64   `json:"status_counts"`
	TypeCounts     map[string]int64   `json:"type_counts"`
}
