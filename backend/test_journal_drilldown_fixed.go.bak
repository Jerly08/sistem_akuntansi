package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

// JournalDrilldownRequest represents the request payload for journal drilldown
type JournalDrilldownRequest struct {
	AccountCodes      []string  `json:"account_codes,omitempty"`
	AccountIds        []int     `json:"account_ids,omitempty"`
	StartDate         time.Time `json:"start_date"`
	EndDate           time.Time `json:"end_date"`
	ReportType        string    `json:"report_type,omitempty"`
	LineItemName      string    `json:"line_item_name,omitempty"`
	MinAmount         *float64  `json:"min_amount,omitempty"`
	MaxAmount         *float64  `json:"max_amount,omitempty"`
	TransactionTypes  []string  `json:"transaction_types,omitempty"`
	Page              int       `json:"page"`
	Limit             int       `json:"limit"`
}

// Test credentials
const (
	BaseURL  = "http://localhost:8080"
	Email    = "admin@company.com"
	Password = "password123"
)

func main() {
	// Step 1: Login to get token
	fmt.Println("ğŸ” Step 1: Logging in...")
	token, err := login()
	if err != nil {
		fmt.Printf("âŒ Login failed: %v\n", err)
		return
	}
	fmt.Printf("âœ… Login successful, token received (length: %d)\n", len(token))

	// Step 2: Test journal drilldown endpoint
	fmt.Println("\nğŸ“Š Step 2: Testing journal drilldown endpoint...")
	
	// Create test request payload
	startDate, _ := time.Parse("2006-01-02", "2025-09-01")
	endDate, _ := time.Parse("2006-01-02", "2025-09-17")
	
	request := JournalDrilldownRequest{
		StartDate: startDate,
		EndDate:   endDate,
		ReportType: "PROFIT_LOSS",
		LineItemName: "Test Line",
		Page:      1,
		Limit:     20,
	}

	err = testJournalDrilldown(token, request)
	if err != nil {
		fmt.Printf("âŒ Journal drilldown test failed: %v\n", err)
		return
	}
	
	fmt.Println("âœ… Journal drilldown endpoint test completed successfully!")
}

// login performs authentication and returns the JWT token
func login() (string, error) {
	loginData := map[string]string{
		"email":    Email,
		"password": Password,
	}
	
	jsonData, err := json.Marshal(loginData)
	if err != nil {
		return "", fmt.Errorf("failed to marshal login data: %w", err)
	}
	
	resp, err := http.Post(BaseURL+"/api/v1/auth/login", "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", fmt.Errorf("failed to make login request: %w", err)
	}
	defer resp.Body.Close()
	
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read login response: %w", err)
	}
	
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("login failed with status %d: %s", resp.StatusCode, string(body))
	}
	
	// Debug: Print raw response
	fmt.Printf("ğŸ” Raw login response: %s\n", string(body))
	
	var result map[string]interface{}
	err = json.Unmarshal(body, &result)
	if err != nil {
		return "", fmt.Errorf("failed to unmarshal login response: %w", err)
	}
	
	// Try different possible response formats
	// Format 1: {"data": {"access_token": "..."}}
	if data, ok := result["data"].(map[string]interface{}); ok {
		if token, ok := data["access_token"].(string); ok {
			return token, nil
		}
		if token, ok := data["token"].(string); ok {
			return token, nil
		}
	}
	
	// Format 2: {"access_token": "..."}
	if token, ok := result["access_token"].(string); ok {
		return token, nil
	}
	
	// Format 3: {"token": "..."}
	if token, ok := result["token"].(string); ok {
		return token, nil
	}
	
	return "", fmt.Errorf("token not found in response. Available keys: %v", getKeys(result))
}

// testJournalDrilldown tests the journal drilldown endpoint
func testJournalDrilldown(token string, request JournalDrilldownRequest) error {
	fmt.Printf("ğŸ“ Testing with request: StartDate=%s, EndDate=%s, ReportType=%s\n", 
		request.StartDate.Format("2006-01-02"), request.EndDate.Format("2006-01-02"), request.ReportType)
	
	jsonData, err := json.Marshal(request)
	if err != nil {
		return fmt.Errorf("failed to marshal request: %w", err)
	}
	
	// Create HTTP client with timeout
	client := &http.Client{
		Timeout: 30 * time.Second,
	}
	
	req, err := http.NewRequest("POST", BaseURL+"/api/v1/journal-drilldown", bytes.NewBuffer(jsonData))
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+token)
	
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("failed to make journal drilldown request: %w", err)
	}
	defer resp.Body.Close()
	
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response: %w", err)
	}
	
	fmt.Printf("ğŸ“Š Response Status: %d\n", resp.StatusCode)
	fmt.Printf("ğŸ“‹ Response Length: %d bytes\n", len(body))
	
	if resp.StatusCode != http.StatusOK {
		fmt.Printf("âŒ Error Response: %s\n", string(body))
		return fmt.Errorf("request failed with status %d", resp.StatusCode)
	}
	
	// Try to parse and display response summary
	var result map[string]interface{}
	err = json.Unmarshal(body, &result)
	if err != nil {
		fmt.Printf("âš ï¸  Could not parse response as JSON: %v\n", err)
		fmt.Printf("ğŸ“„ Raw response: %s\n", string(body)[:200]) // Show first 200 chars
		return nil
	}
	
	// Display response summary
	if data, ok := result["data"].(map[string]interface{}); ok {
		if journalEntries, ok := data["journal_entries"].([]interface{}); ok {
			fmt.Printf("ğŸ“ˆ Found %d journal entries\n", len(journalEntries))
		}
		
		if summary, ok := data["summary"].(map[string]interface{}); ok {
			if totalDebit, ok := summary["total_debit"].(float64); ok {
				fmt.Printf("ğŸ’° Total Debit: %.2f\n", totalDebit)
			}
			if totalCredit, ok := summary["total_credit"].(float64); ok {
				fmt.Printf("ğŸ’° Total Credit: %.2f\n", totalCredit)
			}
			if entryCount, ok := summary["entry_count"].(float64); ok {
				fmt.Printf("ğŸ“Š Entry Count: %.0f\n", entryCount)
			}
		}
	}
	
	fmt.Println("âœ… Journal drilldown endpoint responding correctly")
	return nil
}

// getKeys returns the keys of a map for debugging
func getKeys(m map[string]interface{}) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}
